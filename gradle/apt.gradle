project.ext {
    if (!project.hasProperty('android')) {
        throw new StopExecutionException("either 'android' plugin or 'android-library' plugin must be applied before this 'apt' plugin")
    }

    if (android.hasProperty('applicationVariants')) {
        buildVariants = android.applicationVariants
    } else if (android.hasProperty('libraryVariants')) {
        buildVariants = android.libraryVariants
    } else {
        throw new StopExecutionException('build variants not found. why?')
    }
}

buildVariants.all { variant ->

    //http://stackoverflow.com/questions/18958388/gradle-androidannotations-generates-duplicate-class-errors-need-to-clean-pro

    // ↓ def を付けないと プロジェクトの Dynamic Property になってしまい、常に最後の variant 用のディレクトリが使われてしまう。
    def aptOutputDir = project.file("${project.buildDir}/source/apt_generated")
    def aptOutput = new File(aptOutputDir, variant.dirName)

    println "****************************"
    println "variant: ${variant.name}"
    println "manifest:  ${variant.processResources.manifestFile}"
    println "aptOutput:  ${aptOutput}"
    println "sourceSet: " + new File(variant.dirName).getName()
    println "****************************"

    // Automatically add the generated source code to the source set
    android.sourceSets[new File(variant.dirName).getName()].java.srcDirs += aptOutput

    variant.javaCompile.doFirst {
        aptOutput.mkdirs()
    }

    variant.javaCompile.options.compilerArgs += [
            '-s', aptOutput
    ]

    variant.javaCompile.source = variant.javaCompile.source.filter { p ->
        return !p.getPath().startsWith(aptOutputDir.getPath())
    }
}

android.testVariants.all { variant ->

    //http://stackoverflow.com/questions/18958388/gradle-androidannotations-generates-duplicate-class-errors-need-to-clean-pro

    // ↓ def を付けないと プロジェクトの Dynamic Property になってしまい、常に最後の variant 用のディレクトリが使われてしまう。
    def aptOutputDir = project.file("${project.buildDir}/source/apt_generated")
    def aptOutput = new File(aptOutputDir, variant.dirName)

    println "****************************"
    println "variant: ${variant.name}"
    println "manifest:  ${variant.processResources.manifestFile}"
    println "aptOutput:  ${aptOutput}"
    println "sourceSet: " + new File(variant.dirName).getName()
    println "testSourceSet: " + android.sourceSets["instrumentTest"].java.srcDirs
    println "****************************"


    // Automatically add the generated source code to the source set
    // variantとソースセットの名前が違うので、instrumentTestを固定で指定する
    android.sourceSets.instrumentTest.java.srcDirs += aptOutput

    variant.javaCompile.doFirst {
        aptOutput.mkdirs()
    }

    variant.javaCompile.options.compilerArgs += [
            '-s', aptOutput
    ]

    variant.javaCompile.source = variant.javaCompile.source.filter { p ->
        return !p.getPath().startsWith(aptOutputDir.getPath())
    }
}

